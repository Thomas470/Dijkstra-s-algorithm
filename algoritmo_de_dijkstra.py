# -*- coding: utf-8 -*-
"""Algoritmo de Dijkstra.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i49IYSj05E4H7RGV1jS8xBPO4DvsZ_w9
"""

from collections import defaultdict

class Grafo:
    def __init__(self, direcionado=False, ponderado=False):
        self.lista_adjacencias = defaultdict(list)
        self.ordem = 0
        self.tamanho = 0
        self.direcionado = direcionado
        self.ponderado = ponderado

    # Adiciona um vértice ao grafo
    def adiciona_vertice(self, u):
        if u not in self.lista_adjacencias:
            self.lista_adjacencias[u] = []
            self.ordem += 1

   # Adiciona uma aresta ao grafo
    def adiciona_aresta(self, u, v, peso=None):
        self.adiciona_vertice(u)
        self.adiciona_vertice(v)

        if self.ponderado and peso is None:
            raise ValueError("Peso não especificado para grafo ponderado")

        if self.ponderado:
            aresta = (v, peso)
        else:
            aresta = v

        self.lista_adjacencias[u].append(aresta)
        self.tamanho += 1

        if not self.direcionado and u != v:
            if self.ponderado:
                self.lista_adjacencias[v].append((u, peso))
            else:
                self.lista_adjacencias[v].append(u)

    # Remove um vértice do grafo
    def remove_vertice(self, u):
        if u in self.lista_adjacencias:
            del self.lista_adjacencias[u]
            self.ordem -= 1
            for vertice in self.lista_adjacencias:
                self.lista_adjacencias[vertice] = [(v, peso) for v, peso in self.lista_adjacencias[vertice] if v != u]
                self.tamanho -= 1

    # Remove uma aresta do grafo
    def remove_aresta(self, u, v):
        if u in self.lista_adjacencias:
            if self.ponderado:
                self.lista_adjacencias[u] = [(vertice, peso) for vertice, peso in self.lista_adjacencias[u] if vertice != v]
            else:
                self.lista_adjacencias[u] = [vertice for vertice in self.lista_adjacencias[u] if vertice != v]
            self.tamanho -= 1

            if not self.direcionado and u != v:
                if self.ponderado:
                    self.lista_adjacencias[v] = [(vertice, peso) for vertice, peso in self.lista_adjacencias[v] if vertice != u]
                else:
                    self.lista_adjacencias[v] = [vertice for vertice in self.lista_adjacencias[v] if vertice != u]

    # Verifica se um vértice está no grafo
    def tem_aresta(self, u, v):
        return v in [vertice for vertice, _ in self.lista_adjacencias.get(u, [])]

    def grau(self, u):
        return len(self.lista_adjacencias.get(u, []))

    # Retorna o peso de uma aresta
    def get_peso(self, u, v):
        if self.ponderado:
          for vertice, peso in self.lista_adjacencias.get(u, []):
              if vertice == v:
                  return peso
          return None
        else:
          return print(None)

    # Retorna o grau de entrada de um vértice
    def grau_entrada(self, u):
        if not self.direcionado:
            return print(None)
        grau_entrada = 0
        for vertice in self.lista_adjacencias:
            if u in [v for v, _ in self.lista_adjacencias[vertice]]:
                grau_entrada += 1
        return grau_entrada

    # Retorna o grau de saída de um vértice
    def grau_saida(self, u):
        if not self.direcionado:
            return print(None)
        return len(self.lista_adjacencias.get(u, []))

    def retorna_adjacentes(self, u):
        if self.ponderado:
            return [vertice for vertice, _ in self.lista_adjacencias.get(u, [])]
        else:
            return self.lista_adjacencias.get(u, [])


    # Retorna o número de vértices do grafo
    def get_max_arestas(self):
        if self.direcionado:
            return self.ordem * (self.ordem - 1)
        else:
            return self.ordem * (self.ordem - 1) // 2

    def imprime_lista_adjacencias(self):
        for vertice in self.lista_adjacencias:
            print(f"{vertice}: ")
            if self.ponderado:
                for v, peso in self.lista_adjacencias[vertice]:
                    print(f"('{v}', {peso}) -> ")
            else:
                for v in self.lista_adjacencias[vertice]:
                    print(f"'{v}' -> ")
            print()


    def Dijkstra(self, origem, destino):
        if not self.ponderado:
            raise ValueError("O algoritmo de Dijkstra requer um grafo ponderado")

        # Inicializa o dicionário de distâncias
        distancias = {vertice: float('inf') for vertice in self.lista_adjacencias}
        distancias[origem] = 0


        predecessores = {vertice: None for vertice in self.lista_adjacencias}

        visitados = set()

        while len(visitados) < len(self.lista_adjacencias):
            vertice_atual = None
            menor_distancia = float('inf')
            for vertice, distancia in distancias.items():
                if vertice not in visitados and distancia < menor_distancia:
                    vertice_atual = vertice
                    menor_distancia = distancia

            if vertice_atual is None:
                break

            # Marca o vértice atual como visitado
            visitados.add(vertice_atual)

            for vizinho, peso in self.lista_adjacencias[vertice_atual]:
                distancia = distancias[vertice_atual] + peso
                if distancia < distancias[vizinho]:
                    distancias[vizinho] = distancia
                    predecessores[vizinho] = vertice_atual

        menor_caminho = []
        vertice_atual = destino
        while vertice_atual is not None:
            menor_caminho.insert(0, vertice_atual)
            vertice_atual = predecessores[vertice_atual]

        # Retorna o menor caminho e a distância
        return menor_caminho, distancias[destino]

# Teste
G = Grafo(direcionado=True, ponderado=True)
G.adiciona_aresta("Thomas", "Henrique",3)
G.adiciona_aresta("Thomas", "Theo",6)
G.adiciona_aresta("Henrique", "Leonardo",9)
G.adiciona_aresta("Leonardo", "Henrique",2)
G.adiciona_aresta("Lucca", "Theo",4)
G.adiciona_aresta("Theo", "Gabriel",5)

G.Dijkstra("Thomas", "Gabriel")